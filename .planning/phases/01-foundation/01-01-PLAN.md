---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - manifest.json
  - background.js
  - offscreen/offscreen.html
  - offscreen/offscreen.js
  - popup/popup.html
  - popup/popup.js
  - popup/popup.css
autonomous: false

must_haves:
  truths:
    - "Checking 'Use ZoomMe' in popup turns on the webcam LED"
    - "Unchecking the toggle turns off the webcam LED (stream fully released)"
    - "Opening a new browser window does not re-enable the webcam (session-only state)"
    - "A camera-active indicator in popup reflects the current webcam state accurately"
  artifacts:
    - path: "manifest.json"
      provides: "offscreen + storage permissions, minimum_chrome_version 116"
      contains: "offscreen"
    - path: "background.js"
      provides: "Offscreen lifecycle, port management, storage.session state, message handlers"
      exports: ["ensureOffscreenDocument", "enableCamera", "disableCamera"]
    - path: "offscreen/offscreen.html"
      provides: "Minimal HTML shell with hidden video element for getUserMedia"
      contains: "video"
    - path: "offscreen/offscreen.js"
      provides: "getUserMedia stream lifecycle, port keepalive, START/STOP handlers"
    - path: "popup/popup.html"
      provides: "Checkbox toggle and status indicator elements"
      contains: "toggle"
    - path: "popup/popup.js"
      provides: "Toggle change handler, state refresh, message passing to background"
    - path: "popup/popup.css"
      provides: "Indicator styling for active/inactive states"
  key_links:
    - from: "popup/popup.js"
      to: "background.js"
      via: "chrome.runtime.sendMessage SET_ENABLED / GET_STATE"
      pattern: "sendMessage.*SET_ENABLED"
    - from: "background.js"
      to: "offscreen/offscreen.js"
      via: "chrome.runtime.connect port with START_CAMERA / STOP_CAMERA"
      pattern: "postMessage.*START_CAMERA"
    - from: "offscreen/offscreen.js"
      to: "background.js"
      via: "port messages CAMERA_READY / CAMERA_ERROR / HEARTBEAT"
      pattern: "postMessage.*CAMERA_READY"
    - from: "background.js"
      to: "chrome.storage.session"
      via: "enabled + cameraActive flags"
      pattern: "storage\\.session\\.set"
---

<objective>
Wire up webcam lifecycle: popup toggle -> background service worker -> offscreen document with getUserMedia. Session-only state via chrome.storage.session. Port-based keepalive prevents SW termination.

Purpose: Foundation for all subsequent phases. Camera must reliably start/stop without crashing the service worker.
Output: Working extension that toggles webcam on/off from popup with accurate status indicator.
</objective>

<execution_context>
@/Users/dusan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dusan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@manifest.json
@background.js
@popup/popup.html
@popup/popup.js
@popup/popup.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Offscreen document + background service worker rewrite</name>
  <files>manifest.json, background.js, offscreen/offscreen.html, offscreen/offscreen.js</files>
  <action>
1. Update manifest.json:
   - Add `"permissions": ["offscreen", "storage"]`
   - Add `"minimum_chrome_version": "116"` (required for chrome.runtime.getContexts)
   - Keep existing icons, action, background fields unchanged

2. Create offscreen/offscreen.html:
   - Minimal HTML: doctype, charset meta, hidden video element (id="video", autoplay, playsinline, muted, display:none), script tag loading offscreen.js
   - No styling needed — this document is never visible

3. Create offscreen/offscreen.js:
   - State: `activeStream` (MediaStream|null), `backgroundPort` (Port|null), `heartbeatInterval` (number|null), `isStreaming` (boolean)
   - `connectToBackground()`: opens port named 'offscreen-keepalive', sets up onDisconnect handler that clears heartbeat and reconnects after 500ms delay if isStreaming is true. Starts heartbeat interval at 20s sending { type: 'HEARTBEAT' }
   - `startCamera()`: calls getUserMedia({ video: { width: 640, height: 480, frameRate: { max: 30 } } }), assigns to activeStream, sets video.srcObject, calls video.play(), sends { type: 'CAMERA_READY' } via port. On error: sends { type: 'CAMERA_ERROR', error: err.name }, sets activeStream = null, isStreaming = false
   - `stopCamera()`: calls track.stop() on ALL tracks (stream.getTracks().forEach), nulls activeStream, clears video.srcObject, sets isStreaming = false
   - Port message listener: handles 'START_CAMERA' (set isStreaming=true, call startCamera) and 'STOP_CAMERA' (call stopCamera)
   - On script load: call connectToBackground() immediately

4. Rewrite background.js completely (replace scaffold):
   - `OFFSCREEN_URL` = chrome.runtime.getURL('offscreen/offscreen.html')
   - `offscreenPort` = null (set when port connects)
   - `ensureOffscreenDocument()`: uses chrome.runtime.getContexts({ contextTypes: ['OFFSCREEN_DOCUMENT'], documentUrls: [OFFSCREEN_URL] }) — if length > 0, return early. Otherwise createDocument with reasons: ['USER_MEDIA'], justification string. Do NOT use chrome.offscreen.hasDocument() — it does not exist.
   - `enableCamera()`: await ensureOffscreenDocument(), then post START_CAMERA to offscreenPort (port may not be connected yet — wait briefly or handle in port connect), set storage.session { enabled: true }
   - `disableCamera()`: post STOP_CAMERA to offscreenPort, set storage.session { enabled: false, cameraActive: false }, then check getContexts and closeDocument if exists
   - chrome.runtime.onConnect listener: accept port named 'offscreen-keepalive', store as offscreenPort. On port messages: CAMERA_READY -> set storage.session { cameraActive: true }. CAMERA_ERROR -> set storage.session { cameraActive: false, lastError: msg.error }. HEARTBEAT -> no-op (resets SW timer). On port disconnect -> set offscreenPort = null, set storage.session { cameraActive: false }
   - chrome.runtime.onMessage listener: GET_STATE -> read storage.session { enabled: false, cameraActive: false, lastError: null } and sendResponse. SET_ENABLED -> call enableCamera() or disableCamera() based on msg.enabled, then sendResponse({ ok: true }). Return true for async.
   - Handle race condition in enableCamera: after ensureOffscreenDocument(), the offscreen.js needs time to connect its port. If offscreenPort is null after createDocument, wait up to 2s (polling every 100ms) for the port to connect before sending START_CAMERA. This avoids the "port is null" bug on first enable.
   - chrome.runtime.onStartup listener: set storage.session { enabled: false, cameraActive: false } to ensure clean state on browser restart (belt-and-suspenders with session storage auto-clear)
  </action>
  <verify>
  Load extension in chrome://extensions (developer mode). Check:
  - No errors in service worker console on load
  - manifest.json shows offscreen and storage permissions
  - offscreen/offscreen.html and offscreen/offscreen.js exist and are loadable
  </verify>
  <done>Extension loads without errors. Background script initializes. Offscreen document can be created programmatically.</done>
</task>

<task type="auto">
  <name>Task 2: Popup toggle UI with camera status indicator</name>
  <files>popup/popup.html, popup/popup.js, popup/popup.css</files>
  <action>
1. Rewrite popup/popup.html:
   - Keep existing structure (doctype, charset, viewport, title, css link, script)
   - Replace body content: div.popup containing:
     - h1 "ZoomMe"
     - label.toggle-row containing: span "Use ZoomMe", input#toggle type="checkbox"
     - div#indicator.indicator with text "Camera off" (default state)
   - Keep script tag at bottom

2. Rewrite popup/popup.js:
   - Get references: toggle = getElementById('toggle'), indicator = getElementById('indicator')
   - `refreshState()`: sends { type: 'GET_STATE' } via chrome.runtime.sendMessage, updates toggle.checked from response.enabled, updates indicator text and class based on response.cameraActive (true -> "Camera active" + class "active", false -> "Camera off" + no active class). If response.lastError === 'NotAllowedError', show "Camera permission denied"
   - toggle change listener: sends { type: 'SET_ENABLED', enabled: toggle.checked }, then setTimeout(refreshState, 500) to allow camera startup time
   - DOMContentLoaded -> refreshState()
   - Also listen for storage changes to update indicator in real-time while popup is open: chrome.storage.session.onChanged.addListener — on cameraActive change, call refreshState()

3. Update popup/popup.css:
   - Keep existing base styles (body width 320px, font-family, etc.)
   - Add .toggle-row: flex row, justify-content space-between, align-items center, padding 8px 0
   - Style the checkbox toggle (or keep native — functional is fine for Phase 1)
   - Add .indicator: padding 8px 12px, border-radius 6px, text-align center, background #f0f0f0, color #666
   - Add .indicator.active: background #e8f5e9, color #2e7d32 (green tint for active state)
   - Remove old button styles (button element no longer exists)
  </action>
  <verify>
  Click the extension icon in Chrome toolbar:
  - Popup shows "ZoomMe" heading, "Use ZoomMe" checkbox (unchecked), and "Camera off" indicator
  - Checking the box triggers webcam permission prompt (first time) then webcam LED turns on
  - Indicator changes to "Camera active" (green)
  - Unchecking the box turns off webcam LED, indicator returns to "Camera off"
  </verify>
  <done>Toggle controls webcam. Indicator reflects camera state. Unchecking fully releases the stream (LED off).</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify full webcam lifecycle</name>
  <what-built>Complete webcam lifecycle: popup toggle enables/disables webcam via offscreen document. Session-only state. Port-based keepalive. Status indicator.</what-built>
  <how-to-verify>
    1. Load extension at chrome://extensions (developer mode, point to project folder)
    2. Click ZoomMe icon in toolbar — popup should show "Use ZoomMe" unchecked, "Camera off"
    3. Check the "Use ZoomMe" checkbox — webcam LED should turn on, indicator should show "Camera active" (green)
    4. Uncheck the checkbox — webcam LED should turn off, indicator should show "Camera off"
    5. Check the box again (camera on), then close and reopen the browser entirely
    6. Click ZoomMe icon — checkbox should be unchecked, indicator should show "Camera off" (session-only state confirmed)
    7. Check the box, wait 60+ seconds without interacting, then open popup — indicator should still show "Camera active" (keepalive working)
    8. Open chrome://extensions, check service worker status — should show "active" while camera is running
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- Extension loads in Chrome without manifest or JS errors
- Popup toggle controls webcam start/stop
- Webcam LED turns on when enabled, off when disabled
- Indicator text and color reflect actual camera state
- State resets on browser restart (CAM-02)
- Service worker stays alive while camera is active (heartbeat keepalive)
- No "Only a single offscreen document" errors after SW restart cycles
</verification>

<success_criteria>
- CAM-01: User can enable webcam via "Use ZoomMe" checkbox — webcam LED turns on
- CAM-02: State is session-only — browser restart resets to unchecked/off
- CAM-03: Unchecking stops stream (LED off), offscreen document closed
- CAM-04: Green "Camera active" / grey "Camera off" indicator is accurate
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
